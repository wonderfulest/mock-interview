import type { Question } from "../types";

export const distributed: Question[] = [
  {
    id: "distributed-1",
    track: "分布式系统",
    difficulty: 1,
    prompt: "什么是 CAP 定理？请说明三个要素分别代表什么及其权衡关系。",
    points: [
      "C：Consistency，一致性（所有节点数据一致）",
      "A：Availability，可用性（每个请求都能得到响应）",
      "P：Partition tolerance，分区容错（网络分区时系统仍能工作）",
      "在分区容错前提下，系统需在 C 与 A 之间取舍"
    ],
    answer:
      "CAP 定理指出分布式系统中无法同时满足一致性 C、可用性 A 和分区容错性 P。\n在真实网络环境中，分区容错 P 必须满足。\n因此系统在网络分区时必须在 C 与 A 中取舍：如 CP 模式（Zookeeper）强调一致性，AP 模式（Eureka）强调可用性。",
    tags: ["CAP", "一致性", "分区容错"]
  },
  {
    id: "distributed-2",
    track: "分布式系统",
    difficulty: 2,
    prompt: "请解释一致性模型中的强一致性、最终一致性和因果一致性的区别。",
    points: [
      "强一致性：更新后所有节点立即可见（线性化）; 比如：银行转账、库存扣减等强事务场景。",
      "最终一致性：短暂不一致，最终达到一致; 比如：分布式缓存。",
      "因果一致性：有因果关系的操作保持一致; 像“有逻辑顺序的事件流”——只要有依赖关系的操作按顺序展示，无关的可乱序，提高性能。比如：分布式消息队列、社交网络、协作编辑等有逻辑因果关系的系统。"
    ],
    answer:
      "强一致性要求所有节点视图一致，如同单机执行，延迟高。\n最终一致性允许短暂不一致，系统最终收敛，适合高可用场景。\n因果一致性介于两者之间，保持逻辑顺序但允许部分并发。",
    tags: ["一致性模型", "线性化", "最终一致性"]
  },
  {
    id: "distributed-3-1",
    track: "分布式系统",
    difficulty: 3,
    prompt: "强一致性业务（如转账、库存扣减）要如何实现？请说明常见实现手段及其关键机制。",
    points: [
      "单体系统：利用数据库事务（ACID）和行级锁，保证操作的原子性与隔离性。",
      "分布式数据库：采用共识协议（Raft/Paxos）与同步复制，确保副本间数据线性一致。",
      "分布式事务：通过两阶段提交（2PC）、三阶段提交（3PC）、TCC、Saga 等模式协调跨服务一致性。",
      "TCC 模式：Try-Confirm-Cancel 三步控制资源预留与确认，用于电商库存、支付扣款等场景。",
      "Saga 模式：通过本地事务 + 补偿机制，适合长链路业务，如机票+酒店+保险等联合预订。",
      "工程要点：幂等性、隔离级别（Serializable）、锁粒度控制、Exactly Once 消息语义、故障补偿与事务状态监控。"
    ],
    answer:
      "强一致性业务需保证任意时刻所有节点数据视图一致。\n实现方式包括：\n单节点使用数据库事务（ACID），\n分布式数据库通过共识协议（Raft/Paxos）实现同步复制，\n分布式服务通过分布式事务（2PC、TCC、Saga）协调跨系统一致性。\n工程实践中需关注幂等、锁粒度、隔离级别与补偿机制，以确保线性化一致与业务可靠执行。",
    tags: ["强一致性", "分布式事务", "Raft", "2PC", "TCC", "Saga"]
  },
  {
    id: "distributed-3",
    track: "分布式系统",
    difficulty: 3,
    prompt: "Raft 共识算法如何保证分布式节点之间的一致性？",
    points: [
      "通过 Leader 选举保证写入唯一入口",
      "日志复制机制同步操作日志",
      "多数派提交原则确保安全提交",
      "心跳维持 Leader 权威与集群稳定"
    ],
    answer:
      "Raft 通过选举产生 Leader 作为唯一写入者。\n所有写入先记录到 Leader 日志，再复制到多数节点。\n多数节点确认后日志提交，保证一致性。\nLeader 定期心跳维持集群状态。",
    tags: ["Raft", "共识算法", "日志复制"]
  },
  {
    id: "distributed-4",
    track: "分布式系统",
    difficulty: 3,
    prompt: "分布式事务的常见解决方案有哪些？请简述 2PC、TCC 与本地消息表的机制。",
    points: [
      "2PC：两阶段提交（prepare / commit）",
      "TCC：Try-Confirm-Cancel 补偿机制",
      "本地消息表：本地事务 + 异步消息"
    ],
    answer:
      "2PC 强一致但阻塞严重，协调者单点风险高。\nTCC 将事务拆为 Try/Confirm/Cancel 三阶段，支持业务补偿。\n本地消息表结合事务与异步消息队列，确保最终一致性。",
    tags: ["分布式事务", "2PC", "TCC"]
  },
  {
    id: "distributed-4-1",
    track: "分布式系统",
    difficulty: 3,
    prompt: "请解释分布式事务中 2PC（两阶段提交）机制的实现方式，并说明其为什么被认为强一致但阻塞严重、协调者单点风险高。",
    points: [
      "2PC 由协调者和多个参与者组成，通过两阶段（Prepare / Commit）确保一致性",
      "第一阶段：协调者发出 prepare 请求，参与者预执行并锁资源，返回是否可提交",
      "第二阶段：若全部成功则提交，否则回滚",
      "强一致性：所有节点状态一致（要么全成，要么全败）",
      "阻塞问题：协调者宕机或网络分区时，参与者被动等待，事务长时间占锁",
      "单点风险：协调者失效导致系统无法继续提交或回滚"
    ],
    answer:
      "2PC 是两阶段提交协议，由协调者统一管理多个参与者的事务执行：\n" +
      "第一阶段各参与者预执行并锁定资源；\n" +
      "第二阶段协调者根据投票结果统一提交或回滚，从而实现强一致性。\n" +
      "但其缺点是阻塞严重：协调者故障时，参与者无法得知最终决策而长时间持锁等待。\n" +
      "同时，协调者是全局单点，一旦崩溃可能导致系统挂起或悬挂事务，因此在高可用分布式系统中常被更灵活的方案（如 TCC、消息表）替代。",
    tags: ["2PC", "两阶段提交", "分布式事务", "强一致性"]
  },
  {
    id: "distributed-4-2",
    track: "分布式系统",
    difficulty: 3,
    prompt: "请解释分布式事务中 TCC（Try-Confirm-Cancel）机制的实现原理，并说明其优缺点与适用场景。",
    points: [
      "TCC 将一次业务操作拆分为 Try、Confirm、Cancel 三个阶段",
      "Try：资源预留或校验，确保后续能成功执行",
      "Confirm：正式提交业务操作，需保证幂等性",
      "Cancel：异常或失败时执行补偿回滚，需保证幂等性与空回滚安全",
      "优点：灵活、性能高、最终一致、可避免长时间数据库锁",
      "缺点：业务侵入强、开发成本高、需防悬挂与幂等处理"
    ],
    answer:
      "TCC（Try-Confirm-Cancel）是一种基于业务补偿的分布式事务控制方案，将全局事务拆分为三个阶段：\n" +
      "1. Try 阶段：校验业务逻辑并预留资源（如冻结库存、预授权资金），为后续提交做准备；\n" +
      "2. Confirm 阶段：所有参与方 Try 成功后，统一提交事务，正式生效，要求幂等；\n" +
      "3. Cancel 阶段：任一参与方 Try 失败或超时，执行补偿逻辑释放资源，支持空回滚与幂等处理。\n\n" +
      "TCC 通过业务层的补偿实现最终一致性，不需要像 2PC 那样长时间持锁，性能与可用性更高。\n" +
      "但其缺点是业务侵入强，需要设计三套接口并维护幂等、空回滚、防悬挂、悬挂事务清理等逻辑。\n" +
      "适用于可建模为“可冻结→可提交→可回滚”的场景，如订单支付、库存冻结、资金预授权等。",
    tags: ["TCC", "分布式事务", "补偿机制", "最终一致性", "幂等性"]
  },
  {
    id: "distributed-4-3",
    track: "分布式系统",
    difficulty: 3,
    prompt: "请解释分布式事务中本地消息表机制的实现原理，并说明其如何保证最终一致性及适用场景。",
    points: [
      "核心思想：将消息与业务操作放入同一个本地事务中，确保消息可靠发送",
      "步骤：① 业务方本地事务写入业务数据和消息表 → ② 事务提交 → ③ 异步任务或消息服务扫描消息表并发送至 MQ → ④ 消费方处理消息并确认消费",
      "关键：业务操作与消息落库在同一事务中，保证两者原子性",
      "通过消息重试、消费幂等和补偿机制确保最终一致性",
      "优点：实现简单、对业务侵入小、解耦服务依赖",
      "缺点：消息投递延迟、需要补偿与幂等机制、事务表需定期清理"
    ],
    answer:
      "本地消息表是一种实现分布式事务最终一致性的可靠消息方案，其核心思想是将业务数据与消息记录写入同一个数据库事务中，从而保证消息必然与业务操作保持一致：\n" +
      "业务方在本地事务中同时写入业务数据和一条待发送消息到消息表；\n" +
      "事务提交后，异步任务或定时扫描器读取消息表，将消息投递到消息队列（如 Kafka、RabbitMQ）；\n" +
      "消费方接收消息，执行业务逻辑，并返回消费确认；\n" +
      "生产方标记消息已发送或成功消费，防止重复投递。\n\n" +
      "该机制通过“本地事务 + 异步重试 + 消费幂等”实现最终一致性，避免了跨库分布式事务带来的高耦合和性能问题。适用于支付结果通知、订单状态同步、积分发放等异步一致性业务场景。",
    tags: ["本地消息表", "分布式事务", "可靠消息", "最终一致性", "异步消息"]
  },
  {
    id: "distributed-5",
    track: "分布式系统",
    difficulty: 2,
    prompt: "Zookeeper 在分布式系统中主要起什么作用？",
    points: [
      "提供分布式协调与命名服务",
      "支持 Leader 选举、分布式锁、注册中心",
      "基于 Zab 协议保证强一致性"
    ],
    answer:
      "Zookeeper 提供分布式协调与配置管理功能。\n常用于 Leader 选举、分布式锁、服务注册。\n其 Zab 协议保证强一致性，适合 CP 模式系统。",
    tags: ["Zookeeper", "Zab", "分布式协调"]
  },
  {
    id: "distributed-6",
    track: "分布式系统",
    difficulty: 2,
    prompt: "分布式锁常见的实现方式有哪些？各自优缺点是什么？",
    points: [
      "Redis 锁（SET NX EX + Lua 脚本）",
      "Zookeeper 锁（临时顺序节点）",
      "数据库锁（唯一索引插入）"
    ],
    answer:
      "Redis 实现简单性能高，但容错弱。\nZookeeper 可靠性强但开销大。\n数据库锁实现方便但性能差，适合小规模系统。\n常见优化方案：Redlock 或基于 Zookeeper 的锁。",
    tags: ["分布式锁", "Redis", "Zookeeper"]
  },
  {
    id: "distributed-7",
    track: "分布式系统",
    difficulty: 3,
    prompt: "谈谈微服务架构中的服务注册与发现机制。",
    points: [
      "注册中心保存服务实例信息",
      "服务启动时注册、停止时下线",
      "客户端或网关通过注册中心发现目标服务"
    ],
    answer:
      "注册中心（如 Eureka、Consul、Nacos）负责维护服务实例。\n" +
      "服务启动注册，宕机或下线时自动移除。\n" +
      "服务发现分为客户端模式与服务端模式，客户端发现强调“自己找服务”，服务端发现强调“让网关帮我找”。\n" +
      "客户端模式：调用方可主动发现（Eureka、Consul + Ribbon）\n" +
      "服务端模式：通过网关路由（Nginx、API Gateway（如 Spring Cloud Gateway）、Kubernetes Service + Ingress",
    tags: ["服务注册", "服务发现", "Eureka", "Consul"]
  },
  {
    id: "distributed-8",
    track: "分布式系统",
    difficulty: 2,
    prompt: "负载均衡有哪些常见算法？各自的适用场景是什么？",
    points: [
      "轮询（Round Robin）",
      "加权轮询（Weighted RR）",
      "一致性哈希（Consistent Hashing）",
      "最小连接数（Least Connections）"
    ],
    answer:
      "轮询：请求依次分配到各节点，简单高效，适合节点性能相似的无状态服务。\n" +
      "加权轮询：为每个节点分配权重，高性能节点承担更多流量，适合服务器性能差异明显的场景。\n" +
      "一致性哈希：根据请求 key 哈希映射到环上节点，节点增删时只影响少量请求，常用于缓存、分布式存储系统（如 Redis、Memcached）。\n" +
      "最小连接：根据当前连接数分配请求，避免单节点过载，适合长连接或高负载差异的服务。",
    tags: ["负载均衡", "一致性哈希"]
  },
  {
    id: "distributed-9",
    track: "分布式系统",
    difficulty: 3,
    prompt: "什么是一致性哈希？它如何解决节点增减带来的缓存失效问题？",
    points: [
      "节点映射到哈希环",
      "数据通过哈希定位到最近节点",
      "节点增减仅影响局部数据"
    ],
    answer:
      "一致性哈希将节点与数据映射到环形空间。\n数据分配依据哈希值的顺时针邻近节点。\n当节点变化时，仅迁移相邻部分数据，减少缓存失效。",
    tags: ["一致性哈希", "缓存", "扩展性"]
  },
  {
    id: "distributed-10",
    track: "分布式系统",
    difficulty: 4,
    prompt: "在消息队列系统中，如何保证消息的『不丢失、不重复、按顺序』？",
    points: [
      "不丢失：持久化 + ACK 机制",
      "不重复：幂等性 + 去重表",
      "顺序：分区键 + 单线程消费"
    ],
    answer:
      "通过磁盘持久化与 ACK 机制防止消息丢失。\n通过幂等逻辑、唯一键或去重表防止重复消费。\nKafka 等系统通过分区键与顺序消费模型保证顺序性。",
    tags: ["消息队列", "幂等性", "顺序消费"]
  },
  {
    id: "distributed-10-adv",
    track: "分布式系统",
    difficulty: 4,
    prompt: "在消息队列系统中，如何从『生产者、Broker、消费者』三个阶段，分别保证消息的『不丢失、不重复、按顺序』？",
    points: [
      "1️⃣ 生产者阶段：",
      " - 不丢失：发送前启用消息确认（Confirm/ACK）、失败重试、超时补偿机制；Kafka 使用 acks=all 确认所有副本写入。",
      " - 不重复：使用消息唯一 ID（msgId 或业务主键），防止重复发送；或在发送端做发送状态幂等控制。",
      " - 顺序：同一业务键（如订单ID）发往同一分区；生产端单线程或同步发送。",
      "",
      "2️⃣ Broker 阶段：",
      " - 不丢失：消息持久化（磁盘日志）、多副本复制（Leader-Follower 同步）；开启 `acks=all` 或 `min.insync.replicas` 保证可靠写入。",
      " - 不重复：Broker 自身避免重复存储，通过唯一 offset + partition 确认写入成功后再返回 ACK。",
      " - 顺序：Broker 内部按分区顺序追加日志，严格保证同一分区内消息 FIFO（先入先出）。",
      "",
      "3️⃣ 消费者阶段：",
      " - 不丢失：消费后手动 ACK / commit offset（Kafka 支持 offset 提交）；异常时不提交 offset 可重复消费。",
      " - 不重复：消费逻辑需幂等（如基于唯一业务 ID、去重表、状态检查防止重复扣款/下单）。",
      " - 顺序：同一分区只能由一个消费者线程顺序处理，避免并发打乱；多分区消息需业务侧重建顺序或使用全局队列。",
    ],
    answer:
      "消息可靠性需贯穿生产者、Broker、消费者三环节：\n\n" +
      "✅ **生产者**：启用确认机制（Confirm/ACK）、失败重试与唯一消息ID，确保消息成功写入且不重复。\n" +
      "✅ **Broker**：通过磁盘持久化、多副本复制保证不丢；按分区顺序写入保证 FIFO；重复写入通过 offset 控制避免。\n" +
      "✅ **消费者**：使用手动提交 offset 防止丢失；消费逻辑幂等防止重复；分区内单线程消费保持顺序。\n\n" +
      "整体策略是『端到端可靠 + 幂等 + 有序分区』三位一体，实现消息系统的不丢失、不重复、按顺序传递。",
    tags: ["消息队列", "可靠性", "Kafka", "幂等性", "顺序消费"]
  },
  {
    id: "distributed-11",
    track: "分布式系统",
    difficulty: 4,
    prompt: "什么是 Gossip 协议？它如何保证节点状态的传播一致？",
    points: [
      "节点周期性随机选取目标节点交换状态",
      "通过类似病毒传播的方式实现最终一致",
      "具备去中心化与高容错特性"
    ],
    answer:
      "Gossip 协议模仿流行病传播机制，节点随机选择其他节点同步状态，逐步使全网收敛至一致状态。广泛用于 Consul、Cassandra 等系统中。",
    tags: ["Gossip", "一致性传播", "去中心化"]
  },
  {
    id: "distributed-12",
    track: "分布式系统",
    difficulty: 3,
    prompt: "请说明幂等性在分布式系统中的重要性，以及常见实现方式。",
    points: [
      "幂等性保证重复请求不会引发副作用",
      "实现方式包括唯一请求 ID、幂等表、版本号控制",
      "结合 MQ、重试机制使用"
    ],
    answer:
      "幂等性是分布式系统高可用与重试机制的基础。通过唯一请求 ID 或业务幂等键防止重复执行，常与消息补偿、重试机制配合使用。",
    tags: ["幂等性", "重试", "分布式安全"]
  },
  {
    id: "distributed-13",
    track: "分布式系统",
    difficulty: 4,
    prompt: "分布式缓存一致性问题如何解决？",
    points: [
      "缓存淘汰策略 + 数据过期机制",
      "写穿/写回/延迟双删策略",
      "订阅数据库变更（CDC）实现同步"
    ],
    answer:
      "可通过延迟双删或消息通知机制保持缓存一致；高端方案如基于 CDC（Change Data Capture）监听数据库变更同步缓存。",
    tags: ["缓存一致性", "CDC", "延迟双删"]
  },
  {
    id: "distributed-14",
    track: "分布式系统",
    difficulty: 4,
    prompt: "在分布式系统中如何实现全局唯一 ID？雪花算法的原理是什么？",
    points: [
      "全局唯一 ID 保证不同节点生成不冲突的标识，用于订单号、日志追踪、请求链路等场景",
      "常见实现方式：UUID、数据库自增、号段模式、Redis发号、雪花算法（Snowflake）",
      "雪花算法通过时间戳 + 机器号 + 序列号 组成 64 位 ID，具备高性能与趋势递增特征"
    ],
    answer:
      "在分布式系统中，为避免不同节点生成重复 ID，可采用多种方案：\n" +
      "1. **UUID**：本地生成，无中心依赖，但无序且存储空间大；\n" +
      "2. **数据库自增或号段模式（Segment）**：集中管理号段，批量分配给节点，性能较高但仍依赖数据库；\n" +
      "3. **Redis 发号**：利用 INCR 命令原子递增，适合中高并发但存在网络延迟；\n" +
      "4. **雪花算法（Snowflake）**：通过位运算生成 64 位长整型 ID，由时间戳、机器号、序列号三部分组成：\n" +
      "   - 1bit 符号位固定为 0；\n" +
      "   - 41bit 时间戳（毫秒级），支持约 69 年；\n" +
      "   - 10bit 机器标识（可区分 1024 台节点）；\n" +
      "   - 12bit 序列号（每毫秒支持 4096 个 ID）。\n" +
      "  雪花算法存在时钟回拨、机器号冲突等缺点。\n" +
      "该算法可在本地高并发环境下生成趋势递增、全局唯一 ID，常用于订单号、日志、消息系统等高性能场景。\n" +
      "典型优化包括：时钟回拨保护、机器号动态分配以及分布式容错策略。",
    tags: ["雪花算法", "唯一ID", "分布式发号", "高并发"]
  },
  {
    id: "distributed-15",
    track: "分布式系统",
    difficulty: 3,
    prompt: "分布式限流的常见实现方式有哪些？",
    points: [
      "本地限流：令牌桶、漏桶算法",
      "分布式限流：Redis + Lua 脚本或滑动窗口计数",
      "借助网关层实现全局限流（如 Nginx、Envoy）"
    ],
    answer:
      "分布式限流可通过 Redis 实现集中计数控制；令牌桶适合突发流量，漏桶适合稳定速率控制。云原生架构中常通过网关插件统一限流。",
    tags: ["限流", "令牌桶", "Redis"]
  },
  {
    id: "distributed-16",
    track: "分布式系统",
    difficulty: 5,
    prompt: "跨机房部署中如何解决数据同步延迟与一致性冲突问题？请说明常见策略与架构取舍。",
    points: [
      "1. 数据复制策略：主从复制（异步 / 半同步 / 全同步）影响延迟与一致性平衡；",
      "2. 多活架构：多数据中心同时写入，需引入冲突检测（版本号、向量时钟、Last Write Wins）；",
      "3. 异步事件流：通过消息中间件（Kafka、Pulsar、Binlog）实现解耦与最终一致；",
      "4. 幂等与补偿：利用幂等键、重放机制或业务补偿逻辑应对异步一致性问题；",
      "5. 调度与拓扑优化：就近访问、读写分离、全局时钟（NTP/Hybrid Clock）降低感知延迟。"
    ],
    answer:
      "跨机房部署需在 CAP 模型中权衡一致性与可用性。通常采用主从复制 + 异步事件同步机制实现数据传播，通过多活架构提升可用性，并在业务层设计幂等校验与冲突解决（如版本号、向量时钟）以保证最终一致。对于强一致需求场景，可使用同步复制或分区锁来牺牲部分性能换取实时一致性。",
    tags: ["跨机房", "多活架构", "最终一致性", "异步复制", "冲突解决"]
  },
  {
    id: "distributed-17",
    track: "分布式系统",
    difficulty: 4,
    prompt: "Paxos 与 Raft 的主要区别是什么？",
    points: [
      "Raft 简化了 Paxos 的实现，角色更明确（Leader/Follower/Candidate）",
      "Raft 增加日志复制与快照机制，工程实现更友好",
      "Paxos 理论完整但复杂，Raft 实用性更强"
    ],
    answer:
      "Paxos 是理论共识算法，Raft 则是工程化优化版。Raft 提供更易理解的状态机复制过程，并被广泛用于 etcd、Consul 等项目。",
    tags: ["Paxos", "Raft", "共识算法"]
  },
  {
    id: "distributed-18",
    track: "分布式系统",
    difficulty: 5,
    prompt: "分布式快照算法（Chandy-Lamport）如何工作？",
    points: [
      "用于一致性检查点（Checkpoint）捕获系统全局状态",
      "节点收到标记消息后记录自身状态与通道消息",
      "最终汇总形成全局一致快照"
    ],
    answer:
      "Chandy-Lamport 算法通过标记消息让每个节点在收到标记后记录本地状态及通道未处理消息，从而形成全局一致的系统快照，用于容错与恢复。",
    tags: ["快照算法", "Chandy-Lamport", "一致性检查点"]
  },
  {
    id: "distributed-19",
    track: "分布式系统",
    difficulty: 3,
    prompt: "分布式系统中如何检测节点故障？",
    points: [
      "心跳检测 + 超时判断（如 Ping/Pong）",
      "Gossip 协议传播节点状态",
      "引入 Phi Accrual Failure Detector 动态阈值判断"
    ],
    answer:
      "常见机制为心跳检测配合超时控制，Gossip 协议提高去中心化；Phi 检测器可自适应网络延迟，广泛用于 Cassandra、Akka 等系统。",
    tags: ["故障检测", "Gossip", "Phi Accrual"]
  },
  {
    id: "distributed-20",
    track: "分布式系统",
    difficulty: 5,
    prompt: "谈谈你在实际项目中如何保证分布式系统的可观测性（Observability）。",
    points: [
      "埋点追踪：TraceId + SpanId 构建调用链（OpenTelemetry）",
      "指标监控：Prometheus + Grafana",
      "日志收集：ELK / Loki / Fluentd，统一上下文"
    ],
    answer:
      "可观测性通过『三板斧』实现：日志、指标、链路。利用 TraceId 贯穿请求上下文，结合 Prometheus/Grafana 实现指标监控与告警，ELK 提供全链路排障能力。",
    tags: ["可观测性", "OpenTelemetry", "监控"]
  }
];

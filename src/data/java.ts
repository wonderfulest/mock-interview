import type { Question } from "../types";

export const summary: Question[] = [
    {
    id: "java-1",
    track: "Java基础与性能优化",
    difficulty: 2,
    prompt: "Java 中常见的垃圾回收算法有哪些？它们的原理与适用场景分别是什么？",
    points: [
        "垃圾回收的目标是自动回收不再被引用的对象，释放堆内存空间",
        "常见算法包括：标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）、分代收集（Generational GC）",
        "新生代多采用复制算法（Minor GC），老年代常用标记-清除或标记-整理算法（Major GC）",
        "不同 GC 收集器（如 Serial、Parallel、CMS、G1、ZGC、Shenandoah）基于这些算法组合优化性能"
    ],
    answer:
        "Java 垃圾回收（Garbage Collection, GC）是 JVM 自动内存管理的核心机制，用于释放不再被引用的对象，防止内存泄漏。\n\n" +
        "1️⃣ **标记-清除算法 (Mark-Sweep)**：分两步执行：首先遍历对象图标记所有存活对象，然后清除未标记对象。优点是实现简单，缺点是会产生内存碎片。\n\n" +
        "2️⃣ **复制算法 (Copying)**：将内存分为 From 和 To 两个区域，每次只使用一个。当 GC 发生时，将存活对象复制到另一半空间，然后一次性清空原区域。优点是无碎片、回收快；缺点是空间利用率低（仅 50%）。\n\n" +
        "3️⃣ **标记-整理算法 (Mark-Compact)**：在标记阶段标识存活对象，然后将它们压缩移动到内存一端，清除边界以外的空间。避免碎片，适合老年代大对象回收，但整理阶段耗时较长。\n\n" +
        "4️⃣ **分代收集算法 (Generational GC)**：根据对象生命周期特点，将堆划分为新生代与老年代。新生代采用复制算法（对象存活率低），老年代采用标记-清除或标记-整理算法（对象存活率高）。这是现代 GC 的基础设计思想。\n\n" +
        "5️⃣ **现代垃圾回收器**：\n" +
        "   - **Serial GC**：单线程，适合单核、小内存场景。\n" +
        "   - **Parallel GC（吞吐量优先）**：多线程并行回收，适合批处理类服务。\n" +
        "   - **CMS（并发标记清除）**：减少停顿时间，但会产生碎片。\n" +
        "   - **G1 GC（区域化分代）**：按 Region 管理内存，可预测停顿时间，JDK 9+ 默认。\n" +
        "   - **ZGC / Shenandoah**：超低延迟 GC，暂停时间通常小于 10ms，适合交互式与大堆场景。\n\n" +
        "总体来说，Java GC 算法的演进遵循『空间换时间 → 并行 → 并发 → 低延迟』的路径，以满足不同应用对吞吐与响应的权衡需求。",
    tags: ["JVM", "垃圾回收", "GC算法", "性能优化", "内存管理"]
    }
]